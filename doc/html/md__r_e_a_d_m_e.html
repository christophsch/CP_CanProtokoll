<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CP: CP Protokoll Beschreibung</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md__r_e_a_d_m_e.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CP Protokoll Beschreibung </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>CP-Protokoll Features </h2>
<ul>
<li>Daten- und Teilnehmererkennung</li>
<li>Segmentierung, Desegmentierung fuer beliebig grosse Datenpakete</li>
<li>Fluss-Steuerung</li>
<li>Daten-Konsistenz</li>
<li>Wenig Overhead</li>
<li>Robustheit</li>
</ul>
<h2>Benutzung des CP-Protokolls </h2>
<p>Das CP-Protokoll selbst unterstuetzt keinen Code fuer jeden Mikrocontroller, das Protokoll wurde speziell fuer den Mikrocontroller STM32F303K8 angepasst, und baut auf den von CubeMx: erzeugten Code auf. CubeMX Version 4.20.0, Firmware-Package: FW F3 V1.8.0</p>
<h2>Dokumentation </h2>
<p>Der Code ist hauptsaechlich in den Source-Code Files dokumentiert. Bei Elementen, die im Source-Code nicht verwendet werden, wird in den Header-Files dokomentiert.</p>
<h2>Grobe Uebersicht des Aufbaus: </h2>
<div class="fragment"><div class="line">                            -----------------------</div><div class="line">                           |     Programm Start     |</div><div class="line">                            -----------------------</div><div class="line">                                       |</div><div class="line">                            -----------------------</div><div class="line">                           |   CP-Protokoll_Init   |</div><div class="line">                            -----------------------</div><div class="line">                                       |</div><div class="line">                            -----------------------</div><div class="line">                           |     Main-Routine      |</div><div class="line">                           |                       |</div><div class="line">                           | - Initialisiere       |</div><div class="line">                           |   Sende-Datenobjekt   |</div><div class="line">                           | - Starte              |</div><div class="line">                           |   Senden Datenobjekt  |</div><div class="line">                           |                       |</div><div class="line">                           | - Initialisiere       |</div><div class="line">                           |   Empf.-Datenobjekt   |</div><div class="line">                           | - Starte              |</div><div class="line">                           |   Empf. Datenobjekt   |</div><div class="line">                           |                       |</div><div class="line">                            -----------------------</div><div class="line">                                 |     |  </div><div class="line">             --------------------      | </div><div class="line">            |                          | </div><div class="line"> -----------------------    ----------------------- </div><div class="line">| CAN Empfangs-Prozess  |  | CAN Sende-Prozess     |</div><div class="line">|                       |  |                       |</div><div class="line">| - Empfange CAN-       |  | - Segmentierung       |</div><div class="line">| - Nachrichten         |  |   des Datenobjekts    |</div><div class="line">|   Inerruptgesteuert   |  |   auf einzelne        |</div><div class="line">|   zur Auswertung      |  |   Datenpakete         |</div><div class="line">|                       |  |                       |</div><div class="line">| - Filter ID           |  | - Versende einzelne   |</div><div class="line">| - Filter Frame-Nummer |  |   Datenpakete         |</div><div class="line">| - Speichern der       |  |   Interrupt getrieben |</div><div class="line">|   empfangenen Daten   |  |                       |</div><div class="line">|   in Datenobjekt      |  |                       |</div><div class="line">|                       |  |                       |</div><div class="line"> -----------------------    ----------------------- </div></div><!-- fragment --><h2>File structure </h2>
<ul>
<li><b><a class="el" href="cp__user_8c.html" title="CP Anwender-Interface. ">cp_user.c</a>/.h</b> - Anwender-Interface: Anwenderfunktionen zur Bedienung des CP-Protokolls.</li>
<li><b><a class="el" href="cp__control_8c.html" title="CP_Steuerungsschicht. ">cp_control.c</a>/.h</b> - Steuerungsschicht: Interrupt-getriebener Sende- und Empfangsprozess.</li>
<li><b><a class="el" href="cp__example_8c.html" title="CP Example. ">cp_example.c</a></b> - Beispiel-Applikation, wie Anwender-Funtionen genutzt werden.</li>
<li><b><a class="el" href="main_8c.html">main.c</a></b> - Beispiel-Implementierung zur Beschreibung, wie das CP-Protokoll eingebunden wird.</li>
<li><b>Doxyfile</b> - Konfiguration zur Code-Dokumentation mit Doxygen*.</li>
<li><b><a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a></b> - This file</li>
</ul>
<h2>Beschreiung des CP-Protokolls: </h2>
<h3>Konzept</h3>
<p>Aufbauend auf Protokollschicht 1 und 2 werden in Abstimmung mit der Anforderungsanalyse zur CAN-Kommunikation zwischen den Mikrocontrollern die 3. und 4. Protokollschicht, Vermittlung und Transport, benoetigt. Konkret geht es um die 3 Hauptpunkte: Teilnehmer- / Datenerkennung, Segmentierung zum Versenden groesserer Daten als die Kapazitaet einer einzelnen CAN-Nachricht und eine Fluss-Steuerung zur stoerungsfreien Kommunikation.</p>
<h3>Datenobjekt</h3>
<p>Der Austausch von Daten zwischen den Teilnehmern passiert durch identische Speicherstrukturen auf jedem Mikrocontroller. Somit muss waehrend der Laufzeit kein Speicher allokiert werden, da im Voraus bekannt ist welche Daten versendet und empfangen werden.</p>
<p>Jeder Mikrocontroller besitzt seine eigenen Datenobjekte, sowie Datenobjekte anderer Teilnehmer im CAN-Netzwerk. Die eigenen Datenobjekte werden zur Laufzeit veraendert und koennen auf den CAN-Bus gesendet werden, sodass diese fuer andere Knoten im Netzwerk zur Verfuegung stehen. Die Empfaenger eines Datenobjekts muessen eine identische Datenstruktur im Speicher deklariert haben um dieses <a class="el" href="group___datenobjekt.html">Datenobjekte</a> empfangen, beziehungsweise speichern zu koennen. Bei dem Empfang werden die Daten dann automatisch in das deklarierte <a class="el" href="group___datenobjekt.html">Datenobjekte</a> geschrieben. Von hier aus koennen die Daten, nach erfolgreichem Empfang, durch den Anwender ausgelesen und verwendet werden.</p>
<p>Die Namensgebung der Datenobjekte ist beliebig und nicht festgeschrieben. Ein zu versendendes <a class="el" href="group___datenobjekt.html">Datenobjekte</a> kann dabei ein beliebiger Datentyp sein. Zum Beispiel ist das eine einfache Integer-Variable. Zur Buendelung von mehreren Daten bieten sich ein Array oder ein Struktur-Element an, welches wiederum mit beliebigen Datentypen gefuellt sein kann.</p>
<h3>Datenerkennung</h3>
<p>Zur Erkennung um welches <a class="el" href="group___datenobjekt.html">Datenobjekte</a> es sich handelt wird in dem umgesetzten Protokoll festgelegt, dass jedes Datenobjekt durch mindestens einen nicht anderweitig vergebenen Identifier beschrieben wird. Somit ist eine eindeutige Zuordnung von der ID auf das verwendete Datenobjekt moeglich. Die Zuordnung von einer ID zu einem Datenobjekt erfolgt vor dem Versenden / Empfangen von Datenobjekten in der Initialisierungsphase durch den Anwender. Bei der Laenge von 11-bit des CAN-Identifiers eines Standard-CAN-Frames kann bei einer Anzahl von 128 Bus-Teilnehmern, jeder Knoten 16 unterschiedliche Datenobjekte versenden. Bei einer geringeren Anzahl von Knoten dementsprechend mehr. Die Identifier-Aufteilung zu Datenobjekten wird dem Anwender zur freien Verfuegung ueberlassen. Auch ist der CAN-Identifier nicht fest an ein Datenobjekt gekoppelt. Es wird empfohlen, jedem Datenobjekt einen Identifier zuzuordnen damit es im Programmablauf nicht zu Verwechslungen kommt. Es ist jedoch moeglich ein Datenobjekt abwechselnd durch mehrere verschiedene IDs zu versenden. Umgekehrt darf aber jede ID nur einem Datenobjekt zugeordnet sein. Ein CAN-Hardware-Empfangsfilter direkt auf dem CAN-Controller wird nicht eingesetzt. Generell wird jede Nachricht auf dem BUS empfangen und anschliessend geprueft ob diese Nachricht und somit das Datenobjekt benoetigt wird oder nicht. Sollte der Identifier nicht initialisiert sein oder der Empfang des Datenobjekts nicht gewuenscht, werden diese Nachrichten nach dessen Pruefung verworfen. Eine Teilnehmer-Erkennung erfolgt, wie auch in den unteren CAN-Layers nicht. Diese ist nicht benoetigt und kann durch den Anwender selbst erfolgen. Jedes Datenobjekt kann ueber den Identifier eindeutig gekennzeichnet werden. In dem umgesetzten Protokoll werden keine IDs fuer bestimmte Teilnehmer oder Funktionen blockiert. Somit ist es dem Anwender des Protokolls selbst moeglich Teilnehmer zu erkennen, indem zum Beispiel jeder CAN-Bus-Teilnehmer eine bestimmte ID-Range fuer das Senden von Datenobjekten zugeteilt bekommt.</p>
<h3>Segmentierung</h3>
<p>Eine CAN-Botschaft fasst maximal 8 Bytes an Daten. Da der Versand von Datenmengen schnell 8 Byte (16 ASCII-Zeichen) uebersteigen koennte, wird ein Datenmanagement in der Transportschicht notwendig. Die Nachrichten muessen durch den Sender aufgeteilt und beim Empfaenger wieder zusammengesetzt werden. Um dem Empfaenger in jeder Botschaft mitzuteilen um welchen Teil der Gesamt-Nachricht es sich bei der jeweiligen CAN-Botschaft handelt, werden 2 von 8 Bytes des Datenteils verwendet um diese Information zusaetzlich zu uebermitteln. Bei diesen 2 Bytes an Adressraum fuer die Frame-Erkennung ergibt sich die Maximal-Groesse eines zu uebertragenden Datenobjekts von 216 * 6 Byte = 384 kbyte. Dies ist bei Weitem ausreichend, alleine dadurch, dass der verfuegbare Speicher des Mikrocontrollers 32 Kbyte besitzt. Ein einzelnes Byte an Overhead waere jedoch wenig bei einer sich dann ergebenden Maximal-Groesse von nur einem Kilobyte.</p>
<p>Fluss-Steuerung Das Versenden der Datenobjekte soll durch einen gezielten manuellen Aufruf erfolgen. Da auf den einzelnen Mikrocontrollern wie z.B. dem Boost-Converter zeitkritische Funktionen laufen, soll der Versand eines Datenobjekts schnellst moeglich stattfinden und es soll Anwendungen mit hoeherer Prioritaet nicht unnoetig blockieren. Auf der anderen Seite wird eine Flusssteuerung benoetigt um den Empfang von Datenobjekten zu steuern, sodass der Programm-Ablauf nicht unnoetig lang verzoegert wird und gleichzeitig der Verlust von Datenpaketen verhindert wird. Erreicht und Umgesetzt werden diese Anforderung durch einen Interrupt-getriebenen Empfang und Versand der Datenobjekte.</p>
<h3>Daten-Konsistenz</h3>
<p>Die Interrupt-getriebene CAN-Kommunikation hat zur Folge, dass es zur Daten-Inkonsistenz kommen kann. Dies geschieht, wenn die Daten eines Datenobjekts im Hauptprogramm geaendert werden, obwohl die Daten dieses Objekts noch nicht vollstaendig versendet wurden oder sofern ein Datenobjekt gelesen wird, obwohl die Daten dieses Objekts noch nicht vollstaendig empfangen wurden. Hierbei kann es zu unvorhersehbaren Fehlinformationen kommen. An einem kurzen Beispiel soll dies kurz gezeigt werden. Ein String-Datenobjekt mit dem Inhalt „MOTOR 1 ist in Betrieb“ wird nach 7 Zeichen geteilt und versendet. Der aktuelle Sendezustand von 7 versendeten Zeichen wird gespeichert. Nun wird im Hauptprogramm der String geaendert zu „MOTOR 2 ist ausser Betrieb“. Die Sendefunktion wird nun bei dem 8. Zeichen fortsetzen, was beim Empfaenger zu folgender Nachricht fuehrt: „MOTOR 1 ist ausser Betrieb.“ Eine komplette Fehlinformation. Fuer genanntes Problem gibt es unterschiedliche Loesungsszenarien: Eine waere eine Speicherzugriffs-Regelung, die das aendern der Daten verweigert, sofern diese Daten noch nicht komplett versendet wurden. Der Implementierungsaufwand ist hier verhaeltnismaessig hoch. Ein weiterer Loesungsansatz waere, die Daten des Datenobjekts vor dem Senden zu kopieren und die Kopie der Daten zu versenden. Hierzu muss jedoch Speicher zu Verfuegung gestellt werden. Dies kann erfolgen, indem fuer jedes Datenobjekt eine zusaetzliche Datenobjekt-Kopie anlegt wird und der Sende- und Empfangs-Funktion die Adressen beider Datenobjekte mitteilt werden. Besser waere dann eine dynamische Speicherplatz-Reservierung zur Laufzeit des Programms um nicht unnoetig viel Speicherplatz zu verbrauchen. Da die Wahrscheinlichkeit extrem gering ist, waehrend des kurzen Sendeprozesses die Werte des Datenobjekts zu aendern oder waehrend des Empfangs das Datenobjekt auszulesen wird auf die Implementierung der oben genannten Moeglichkeiten verzichtet und dem Anwender eine einfache Moeglichkeit zur Ueberpruefung des aktuellen Sende- und Empfangs-Status geliefert. Somit kann sichergestellt werden, das Datenobjekt erst nach erfolgreichem Versand/Empfang zu schreiben/lesen.</p>
<h3>Aufbau und Dateistruktur</h3>
<p>Das entwickelte Protokoll besteht aus 2 Ebenen und 4 Dateien. Wobei unterschieden wird zwischen dem Anwender-Interface und der Steuerungs-Ebene. Dabei ist der Name „Anwender-Interface“ nicht gleichzusetzen mit der Anwendungsschicht des oben beschriebenen OSI-Modells. Der Name wurde gewaehlt, da das „Anwender-Interface“ dem Anwender des entwickelten CAN-Protokolls Funktionen zur Verfuegung stellt, die fuer den regulaeren Betrieb der CAN-Protokoll-Kommunikation benoetigt werden. Diese Funktionen werden durch das Einbinden der Datei <b><a class="el" href="cp__user_8h.html" title="CP Anwender-Interface. ">cp_user.h</a></b> zur Verfuegung gestellt. Nachfolgende Abbildung veranschaulicht die Zusammenhaenge. Die Richtung der Pfeile zeigt die Richtung des Funktionsaufrufs und spiegelt nicht die Richtung des Datenflusses wieder.</p>
<p>In der Source-Datei <b><a class="el" href="cp__user_8c.html" title="CP Anwender-Interface. ">cp_user.c</a></b> sind die Anwender-Jede Anwenderfunktion erhaelt den Rueckgabetyp <a class="el" href="cp__user_8h.html#addfbccf38eb4a3a39a54f36645572b6f" title="Statuswerte. ">CP_StatusTypeDef</a>. Dieser beschreibt, ob die Funktion erfolgreich ausgefuehrt wurde. Die gleichen Werte werden, wie oben gezeigt, auch fuer den Kommunikations-Zustand (Status) der Datenobjekte verwendet.</p>
<p>Die Steuerungs-Ebene ist die Schicht zwischen den HAL-Funktionen und dem Anwender-Interface. So enthaelt die Datei <b><a class="el" href="cp__control_8c.html" title="CP_Steuerungsschicht. ">cp_control.c</a></b> die zwei Kernfunktionen des Interrupt-getriebenen Sende- und Empfangsprozesses. Dazu finden stehen hier Steuerungs- und Verwaltungsfunktionen zur Verfuegung, die von den Anwenderfunktionen benoetigt werden, worauf der Anwender selbst aber nicht zugreifen muss. Zum Beispiel ist das eine Funktion, die ueberprueft ob eine bestimmte ID bereits initialisiert ist, indem eine Liste durchsucht wird. In der dazugehoerigen Header-Datei <b><a class="el" href="cp__control_8h.html" title="CP_Steuerungsschicht. ">cp_control.h</a></b> sind diese Funktionen und Variablen deklariert, um den Zugriff durch die Anwenderfunktionen zu ermoeglichen. Fuer den Anwender des CAN-Protokolls ist nur die Datei <b><a class="el" href="cp__user_8h.html" title="CP Anwender-Interface. ">cp_user.h</a></b> relevant. Diese enthaelt die Deklaration und damit den Aufbau der Datenobjekte, die vom Anwender manuell im Code bearbeitet werden. Des Weiteren befinden sich hier Definitionen von nutzer-spezifischen Parametern und Verweise auf alle Funktionen, die vom Nutzer verwendet werden koennen.</p>
<p>Die Funktionen und Dateien des Protokolls werden mit dem Kuerzel „CP_“ zur direkten Erkennung gekennzeichnet (Abkuerzung fuer CAN-Protokoll). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jul 2 2017 15:53:33 for CP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
