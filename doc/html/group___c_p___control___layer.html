<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CP: CP Interne Steuerung</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___c_p___control___layer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">CP Interne Steuerung</div>  </div>
</div><!--header-->
<div class="contents">

<p>Interne Steuerung des CP-Protokolls.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for CP Interne Steuerung:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___c_p___control___layer.png" border="0" alt="" usemap="#group______c__p______control______layer"/>
<map name="group______c__p______control______layer" id="group______c__p______control______layer">
<area shape="rect" id="node1" href="group___fehlermanagement.html" title="Fehlermanagement und Auslesen der Fehlerliste. " alt="" coords="200,5,333,32"/>
<area shape="rect" id="node3" href="group___steuerungsfelder.html" title="CP Protokoll Steuerungsfelder / ControlFields. " alt="" coords="207,56,326,83"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___fehlermanagement"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___fehlermanagement.html">Fehlermanagement</a></td></tr>
<tr class="memdesc:group___fehlermanagement"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fehlermanagement und Auslesen der Fehlerliste. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___steuerungsfelder"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___steuerungsfelder.html">Steuerungsfelder</a></td></tr>
<tr class="memdesc:group___steuerungsfelder"><td class="mdescLeft">&#160;</td><td class="mdescRight">CP Protokoll Steuerungsfelder / ControlFields. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:cp__control_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cp__control_8c.html">cp_control.c</a></td></tr>
<tr class="memdesc:cp__control_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CP_Steuerungsschicht. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:cp__control_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cp__control_8h.html">cp_control.h</a></td></tr>
<tr class="memdesc:cp__control_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">CP_Steuerungsschicht. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac3940c9c2948ca63ee5864f258f2ba94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_p___control___layer.html#gac3940c9c2948ca63ee5864f258f2ba94">HAL_CAN_TxCpltCallback</a> (CAN_HandleTypeDef *CanHandle)</td></tr>
<tr class="memdesc:gac3940c9c2948ca63ee5864f258f2ba94"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN-SENDE-PROZESS Interrupt Callback Transmit.  <a href="#gac3940c9c2948ca63ee5864f258f2ba94">More...</a><br /></td></tr>
<tr class="separator:gac3940c9c2948ca63ee5864f258f2ba94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68d94b22db3d280c9915d5f49db08558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_p___control___layer.html#ga68d94b22db3d280c9915d5f49db08558">HAL_CAN_RxCpltCallback</a> (CAN_HandleTypeDef *CanHandle)</td></tr>
<tr class="memdesc:ga68d94b22db3d280c9915d5f49db08558"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN-EMPFANGS-PROZESS.  <a href="#ga68d94b22db3d280c9915d5f49db08558">More...</a><br /></td></tr>
<tr class="separator:ga68d94b22db3d280c9915d5f49db08558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga823ffe3eaa8088a3ba4fd179ec4ef19c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cp__user_8h.html#addfbccf38eb4a3a39a54f36645572b6f">CP_StatusTypeDef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_p___control___layer.html#ga823ffe3eaa8088a3ba4fd179ec4ef19c">CP_CAN_Init</a> ()</td></tr>
<tr class="memdesc:ga823ffe3eaa8088a3ba4fd179ec4ef19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Other Functions.  <a href="#ga823ffe3eaa8088a3ba4fd179ec4ef19c">More...</a><br /></td></tr>
<tr class="separator:ga823ffe3eaa8088a3ba4fd179ec4ef19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7939fccab7a0ec1f4613e078ac059fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_p___control___layer.html#ga7939fccab7a0ec1f4613e078ac059fce">CP_InitControlFieldsRx</a> ()</td></tr>
<tr class="memdesc:ga7939fccab7a0ec1f4613e078ac059fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialisierung / Zuruecksetzen aller Steuerungsfelder.  <a href="#ga7939fccab7a0ec1f4613e078ac059fce">More...</a><br /></td></tr>
<tr class="separator:ga7939fccab7a0ec1f4613e078ac059fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86b34e2b3f14d45de44556d9e088f246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_p___control___layer.html#ga86b34e2b3f14d45de44556d9e088f246">CP_InitControlFieldsTx</a> ()</td></tr>
<tr class="memdesc:ga86b34e2b3f14d45de44556d9e088f246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialisierung / Zuruecksetzen aller Steuerungsfelder.  <a href="#ga86b34e2b3f14d45de44556d9e088f246">More...</a><br /></td></tr>
<tr class="separator:ga86b34e2b3f14d45de44556d9e088f246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70018c5daa72a7222f91fa306b15e0e8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_p___control___layer.html#ga70018c5daa72a7222f91fa306b15e0e8">CP_searchIDRx</a> (uint16_t ID)</td></tr>
<tr class="memdesc:ga70018c5daa72a7222f91fa306b15e0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suche einen Identifier in dem ID-Steuerungsfeld-Array.  <a href="#ga70018c5daa72a7222f91fa306b15e0e8">More...</a><br /></td></tr>
<tr class="separator:ga70018c5daa72a7222f91fa306b15e0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f739472d6ff218cc120dd78c21b5568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_p___control___layer.html#ga8f739472d6ff218cc120dd78c21b5568">CP_SaveErrorCode</a> (uint32_t ErrorCode)</td></tr>
<tr class="memdesc:ga8f739472d6ff218cc120dd78c21b5568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Speichern eines Fehlercodes in die Fehlerliste.  <a href="#ga8f739472d6ff218cc120dd78c21b5568">More...</a><br /></td></tr>
<tr class="separator:ga8f739472d6ff218cc120dd78c21b5568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f50dd09a65bf48c31926f5aa9b162e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_p___control___layer.html#ga5f50dd09a65bf48c31926f5aa9b162e7">HAL_CAN_ErrorCallback</a> (CAN_HandleTypeDef *hcan)</td></tr>
<tr class="memdesc:ga5f50dd09a65bf48c31926f5aa9b162e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fangen der Canfehler aus der HAL-Schicht.  <a href="#ga5f50dd09a65bf48c31926f5aa9b162e7">More...</a><br /></td></tr>
<tr class="separator:ga5f50dd09a65bf48c31926f5aa9b162e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac997e9b383c699d06caa088a64dbac90"><td class="memItemLeft" align="right" valign="top">CAN_FilterConfTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_p___control___layer.html#gac997e9b383c699d06caa088a64dbac90">sFilterConfig</a></td></tr>
<tr class="memdesc:gac997e9b383c699d06caa088a64dbac90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable fuer die CAN-Filterkonfiguration.  <a href="#gac997e9b383c699d06caa088a64dbac90">More...</a><br /></td></tr>
<tr class="separator:gac997e9b383c699d06caa088a64dbac90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5889a924e4690d2d5f800001ee62776c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_p___control___layer.html#ga5889a924e4690d2d5f800001ee62776c">CP_LockCANtx</a> = 0</td></tr>
<tr class="memdesc:ga5889a924e4690d2d5f800001ee62776c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable zum Sperren der Parallelen Bearbeitung des CallBack-SendeProzess.  <a href="#ga5889a924e4690d2d5f800001ee62776c">More...</a><br /></td></tr>
<tr class="separator:ga5889a924e4690d2d5f800001ee62776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2641e3fde6fa5631f6ff5500078cef1f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_p___control___layer.html#ga2641e3fde6fa5631f6ff5500078cef1f">missed_ir</a> = 0</td></tr>
<tr class="memdesc:ga2641e3fde6fa5631f6ff5500078cef1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable zum Zaehlen der blockierten Interrupts fuer eine spaetere wiederholte Ausfuehrung.  <a href="#ga2641e3fde6fa5631f6ff5500078cef1f">More...</a><br /></td></tr>
<tr class="separator:ga2641e3fde6fa5631f6ff5500078cef1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Interne Steuerung des CP-Protokolls. </p>
<p>Der Kern der Steuerungsschicht ist der automatisierte Sende- und Empfangsprozess. Damit keine Wartezeiten auftreten, bis CAN-Nachrichten empfangen oder versendet sind, werden beide Funktionen durch Interrupts gesteuert. Hierfuer muss der Zustand des aktuellen Sende- oder Empfangsvorgang in <a class="el" href="group___steuerungsfelder.html">Steuerungsfelder</a> gespeichert werden. Zusaetzlich finden in der Steuerungs-Schicht mehrere Hilfsfunktionen Platz, um z.B. um in einer Liste nach bereits initialisierten Identifier zu suchen: <a class="el" href="group___c_p___control___layer.html#ga70018c5daa72a7222f91fa306b15e0e8" title="Suche einen Identifier in dem ID-Steuerungsfeld-Array. ">CP_searchIDRx()</a>. Oder eine Funktion um aufgetretene Fehler zu sortieren und in einer Liste zu speichern: <a class="el" href="group___c_p___control___layer.html#ga8f739472d6ff218cc120dd78c21b5568" title="Speichern eines Fehlercodes in die Fehlerliste. ">CP_SaveErrorCode()</a>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga823ffe3eaa8088a3ba4fd179ec4ef19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga823ffe3eaa8088a3ba4fd179ec4ef19c">&#9670;&nbsp;</a></span>CP_CAN_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cp__user_8h.html#addfbccf38eb4a3a39a54f36645572b6f">CP_StatusTypeDef</a> CP_CAN_Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Other Functions. </p>
<p>Initialisierung / Zuruecksetzen der CP-Funktionen.</p>
<ul>
<li>Intitialisierung des CP-Protokolls.</li>
<li>Erst-Initialisierung der ControllFields.</li>
<li>CAN initialisieren</li>
<li>CAN Peripherie initialisieren</li>
<li>CAN Empfangsfilter erstellen</li>
<li>CAN Start Interrupts fuer Empfang</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Status ob Funktion ohne Fehler ausgefuehrt wurde </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___c_p___control___layer_ga823ffe3eaa8088a3ba4fd179ec4ef19c_icgraph.png" border="0" usemap="#group___c_p___control___layer_ga823ffe3eaa8088a3ba4fd179ec4ef19c_icgraph" alt=""/></div>
<map name="group___c_p___control___layer_ga823ffe3eaa8088a3ba4fd179ec4ef19c_icgraph" id="group___c_p___control___layer_ga823ffe3eaa8088a3ba4fd179ec4ef19c_icgraph">
<area shape="rect" id="node2" href="main_8c.html#a840291bc02cba5474a4cb46a9b9566fe" title="main" alt="" coords="152,5,203,32"/>
</map>
</div>

</div>
</div>
<a id="ga7939fccab7a0ec1f4613e078ac059fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7939fccab7a0ec1f4613e078ac059fce">&#9670;&nbsp;</a></span>CP_InitControlFieldsRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CP_InitControlFieldsRx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialisierung / Zuruecksetzen aller Steuerungsfelder. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___c_p___control___layer_ga7939fccab7a0ec1f4613e078ac059fce_icgraph.png" border="0" usemap="#group___c_p___control___layer_ga7939fccab7a0ec1f4613e078ac059fce_icgraph" alt=""/></div>
<map name="group___c_p___control___layer_ga7939fccab7a0ec1f4613e078ac059fce_icgraph" id="group___c_p___control___layer_ga7939fccab7a0ec1f4613e078ac059fce_icgraph">
<area shape="rect" id="node2" href="group___c_p___control___layer.html#ga823ffe3eaa8088a3ba4fd179ec4ef19c" title="Initialisierung / Zuruecksetzen der CP&#45;Funktionen. " alt="" coords="209,5,308,32"/>
<area shape="rect" id="node3" href="main_8c.html#a840291bc02cba5474a4cb46a9b9566fe" title="main" alt="" coords="356,5,407,32"/>
</map>
</div>

</div>
</div>
<a id="ga86b34e2b3f14d45de44556d9e088f246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86b34e2b3f14d45de44556d9e088f246">&#9670;&nbsp;</a></span>CP_InitControlFieldsTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CP_InitControlFieldsTx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialisierung / Zuruecksetzen aller Steuerungsfelder. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___c_p___control___layer_ga86b34e2b3f14d45de44556d9e088f246_icgraph.png" border="0" usemap="#group___c_p___control___layer_ga86b34e2b3f14d45de44556d9e088f246_icgraph" alt=""/></div>
<map name="group___c_p___control___layer_ga86b34e2b3f14d45de44556d9e088f246_icgraph" id="group___c_p___control___layer_ga86b34e2b3f14d45de44556d9e088f246_icgraph">
<area shape="rect" id="node2" href="group___c_p___control___layer.html#ga823ffe3eaa8088a3ba4fd179ec4ef19c" title="Initialisierung / Zuruecksetzen der CP&#45;Funktionen. " alt="" coords="208,5,307,32"/>
<area shape="rect" id="node3" href="main_8c.html#a840291bc02cba5474a4cb46a9b9566fe" title="main" alt="" coords="355,5,405,32"/>
</map>
</div>

</div>
</div>
<a id="ga8f739472d6ff218cc120dd78c21b5568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f739472d6ff218cc120dd78c21b5568">&#9670;&nbsp;</a></span>CP_SaveErrorCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CP_SaveErrorCode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ErrorCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Speichern eines Fehlercodes in die Fehlerliste. </p>
<p>Diese Funktion speichert den uebergebenen Fehlercode in ein Array mit 3 Feldern. Die sogenannte Fehlerliste <a class="el" href="group___fehlermanagement.html#gad0304b9c4141ddefb4b6d0a4ea60a566" title="Fehler-Historie der aufgetretenen Fehler. ">CP_LastErrorCodes</a>[3] Der zuletzt entstandene Fehler ist immer auf dem Arrayplatz 0. Bei einem neuen Fehler, ruecken alle Fehler um einen Platz nach unten in der Liste. Der letzte fliegt raus. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___c_p___control___layer_ga8f739472d6ff218cc120dd78c21b5568_icgraph.png" border="0" usemap="#group___c_p___control___layer_ga8f739472d6ff218cc120dd78c21b5568_icgraph" alt=""/></div>
<map name="group___c_p___control___layer_ga8f739472d6ff218cc120dd78c21b5568_icgraph" id="group___c_p___control___layer_ga8f739472d6ff218cc120dd78c21b5568_icgraph">
<area shape="rect" id="node2" href="group___c_p___control___layer.html#gac3940c9c2948ca63ee5864f258f2ba94" title="Interrupt Callback Functions. " alt="" coords="188,62,363,89"/>
<area shape="rect" id="node3" href="group___c_p___user___interface.html#ga90c80a3049c202d757fdf0dba892634b" title="Starte Sendevorgang der initialisierten ID. " alt="" coords="417,163,506,190"/>
<area shape="rect" id="node6" href="group___c_p___control___layer.html#ga68d94b22db3d280c9915d5f49db08558" title="CAN&#45;EMPFANGS&#45;PROZESS. " alt="" coords="187,113,364,139"/>
<area shape="rect" id="node7" href="group___c_p___control___layer.html#ga823ffe3eaa8088a3ba4fd179ec4ef19c" title="Initialisierung / Zuruecksetzen der CP&#45;Funktionen. " alt="" coords="412,50,511,77"/>
<area shape="rect" id="node8" href="group___c_p___control___layer.html#ga5f50dd09a65bf48c31926f5aa9b162e7" title="Fangen der Canfehler aus der HAL&#45;Schicht. " alt="" coords="192,214,359,241"/>
<area shape="rect" id="node9" href="group___c_p___user___interface.html#ga0ef5bb0c0303eb60e2f5531bab5f7aa7" title="Intitialisierung der Transmit&#45;Routine fuer einen bestimmten Identifier. " alt="" coords="422,315,501,342"/>
<area shape="rect" id="node10" href="group___c_p___user___interface.html#gab825e378caf00b46ed3dcf4b9cb251ae" title="Intitialisierung der Empfangs&#45;Routine fuer einen bestimmten Identifier. " alt="" coords="421,366,501,393"/>
<area shape="rect" id="node11" href="group___c_p___user___interface.html#ga7c85b1fcb0480c78d88f1417f30a2a4b" title="Einmaliges Starten der Empfangs&#45;Routine von einem initialisierten Datenobjekt. " alt="" coords="416,417,507,443"/>
<area shape="rect" id="node12" href="group___c_p___user___interface.html#ga2e9ac36e741deeb45e538e922d68432b" title="Zuruecksetzen der ID und Loeschen der Elemente im Steuerungselement. " alt="" coords="225,265,325,291"/>
<area shape="rect" id="node4" href="group___c_p___example.html#gae907f73b0ed0c7eb71962eebfdd4c31a" title="Beispielprogamm zur Nutzung des CP&#45;Protokolls. " alt="" coords="559,290,655,317"/>
<area shape="rect" id="node5" href="main_8c.html#a840291bc02cba5474a4cb46a9b9566fe" title="main" alt="" coords="703,211,753,238"/>
</map>
</div>

</div>
</div>
<a id="ga70018c5daa72a7222f91fa306b15e0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70018c5daa72a7222f91fa306b15e0e8">&#9670;&nbsp;</a></span>CP_searchIDRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CP_searchIDRx </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suche einen Identifier in dem ID-Steuerungsfeld-Array. </p>
<dl class="section return"><dt>Returns</dt><dd>Array-Index des gefundenen Identifiers, Ansonsten -1 </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___c_p___control___layer_ga70018c5daa72a7222f91fa306b15e0e8_icgraph.png" border="0" usemap="#group___c_p___control___layer_ga70018c5daa72a7222f91fa306b15e0e8_icgraph" alt=""/></div>
<map name="group___c_p___control___layer_ga70018c5daa72a7222f91fa306b15e0e8_icgraph" id="group___c_p___control___layer_ga70018c5daa72a7222f91fa306b15e0e8_icgraph">
<area shape="rect" id="node2" href="group___c_p___control___layer.html#ga68d94b22db3d280c9915d5f49db08558" title="CAN&#45;EMPFANGS&#45;PROZESS. " alt="" coords="168,5,345,32"/>
<area shape="rect" id="node3" href="group___c_p___user___interface.html#gab825e378caf00b46ed3dcf4b9cb251ae" title="Intitialisierung der Empfangs&#45;Routine fuer einen bestimmten Identifier. " alt="" coords="217,56,297,83"/>
<area shape="rect" id="node6" href="group___c_p___user___interface.html#ga7c85b1fcb0480c78d88f1417f30a2a4b" title="Einmaliges Starten der Empfangs&#45;Routine von einem initialisierten Datenobjekt. " alt="" coords="211,107,302,133"/>
<area shape="rect" id="node7" href="group___c_p___user___interface.html#ga464899a6f4692441bf2990df962e71cc" title="Abfrage des aktuellen Empfangs&#45;Status von einem Datenobjekt. " alt="" coords="206,157,307,184"/>
<area shape="rect" id="node8" href="group___c_p___user___interface.html#ga2e9ac36e741deeb45e538e922d68432b" title="Zuruecksetzen der ID und Loeschen der Elemente im Steuerungselement. " alt="" coords="207,208,307,235"/>
<area shape="rect" id="node4" href="group___c_p___example.html#gae907f73b0ed0c7eb71962eebfdd4c31a" title="Beispielprogamm zur Nutzung des CP&#45;Protokolls. " alt="" coords="393,132,489,159"/>
<area shape="rect" id="node5" href="main_8c.html#a840291bc02cba5474a4cb46a9b9566fe" title="main" alt="" coords="537,132,588,159"/>
</map>
</div>

</div>
</div>
<a id="ga5f50dd09a65bf48c31926f5aa9b162e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f50dd09a65bf48c31926f5aa9b162e7">&#9670;&nbsp;</a></span>HAL_CAN_ErrorCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_CAN_ErrorCallback </td>
          <td>(</td>
          <td class="paramtype">CAN_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hcan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fangen der Canfehler aus der HAL-Schicht. </p>
<p>Bei einem entstehenden CAN-Fehler auf Controller-Ebene wird ein Interrupt ausgeloesst. Diese Callback-Funktion wird daraufhin aufgerufen. Dessen Aufgabe ist es aus dem CAN-Handle-Objekt den Fehlercode auszulesen und diesen mit der Funktion <a class="el" href="group___c_p___control___layer.html#ga8f739472d6ff218cc120dd78c21b5568" title="Speichern eines Fehlercodes in die Fehlerliste. ">CP_SaveErrorCode()</a> in die Fehlerliste zu speichern. Siehe auch<a class="el" href="group___fehlermanagement.html">Fehlermanagement</a>. </p>

</div>
</div>
<a id="ga68d94b22db3d280c9915d5f49db08558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68d94b22db3d280c9915d5f49db08558">&#9670;&nbsp;</a></span>HAL_CAN_RxCpltCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_CAN_RxCpltCallback </td>
          <td>(</td>
          <td class="paramtype">CAN_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>CanHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN-EMPFANGS-PROZESS. </p>
<ul>
<li><p class="startli">Beschreibung und Inhalte der Funktion:</p>
<p class="startli">Pruefen ob der Empfang fuer angelegte ID bereits freigeschaltet ist. Die Freischaltung erfolgt in der Funktion <a class="el" href="group___c_p___user___interface.html#ga7c85b1fcb0480c78d88f1417f30a2a4b" title="Einmaliges Starten der Empfangs-Routine von einem initialisierten Datenobjekt. ">CP_StartRx()</a> durch das Setzen des StatusRx auf CP_BUSY</p>
<p class="startli">Sollte ein Datenobjekt auf mehrere CAN-Nachrichten aufgeteilt werden, wird vorausgesetzt, dass die Reihenfolge der aufgeteilten Nachrichten eingehalten wird. Ohne diese Bedingung haette jede empfangene Nachrichten-Nummer gespeichert werden muessen um bei jedem Empfang eines Datenpakets zu pruefen, ob dieses Paket bereits empfangen wurden und welche noch ausstehen.</p>
<p class="startli">Fuer die Ueberpruefung ob die erwartete Framenummer erhalten wurde, wird diese Anzahl aus dem Offset (d.h. der bereits Empfangenen Datenbytes) berechnet und anschliessend mit der Nachrichten Nummer aus der empfangenen CAN-Nachricht verglichen.</p>
<p class="startli">Sofern dies empfange Paketnummer nicht die Erwaretete ist, kann nicht sichergestellt werden, dass alle Nachrichten fuer dieses Datenobjekt empfangen werden. Daher muss der Empfang fuer dieses Datenobjekt abgebrochen werden. Das Steuerungsfeld Status fuer diese ID wird dann auf den Fehlerstatus CP_ERROR gesetzt. Sollte es sich jedoch um die erste FrameNummer (=1) handeln, d.h. das erste Datenpaket eines Datenobjekts, wird der Offset zurueck gesetzt und somit der Empfang des Datenobjekts erneut begonnen, ohne dass der Empfang fuer diese ID erneut aktiviert werden muss. Somit kann ein Knoten, der das Senden eines Datenobjekts aufgrund eines Fehlers abbricht, den Sendevorgang neu starten ohne dass der Empfaenger in den Fehlerzustand kommt. Allerdings ist das Datenobjekt in dieser Zwischenzeit immer im Status des Empfangsmodus und sollte nicht ausgelesen werden, da die Daten nicht konsistent sind.</p>
<p class="startli">Im naechsten Schritt wird ein Zeiger erstellt, der fuer auf die Adresse des naechsten zu bearbeitenden Bytes im Datenobjekt zeigt.</p>
<p class="startli">Aehnlich wie beim Sendeprozess, werden nun in einer Schleife die Dateninhalte zwischen der CAN-Nachricht und dem Datenobjekt kopiert. Mit jedem Schleifendurchlauf wird ein Byte aus der empfangenen CAN-Nachricht in das aktuelle Byte des Datenobjekts gespeichert. Anschliessend wird vor dem naechsten Durchlauf die Adresse des Zeigers und der Offst um eine Stelle erhoeht. Dies geschieht solange bis die Laenge der Nachricht (DLC) erreicht ist. Da die ersten zwei Bytes die Paketnummerierung enthalten also bis maximal 6 Durchlaeufe.</p>
<p class="startli">Sofern der gespeicherte Offset groesser ist, als die Groesse des Datenobjekts ist ein Fehler entstanden. Dieser Fall kann zum Beispiel auftreten, wenn der Empfaengerknoten unter diesem Identifier ein anderes (kleineres) Datenobjekt erwartet, als vom Sende-Knoten initialisiert und gesendet wird.</p>
<p class="startli">Wenn alle Daten des Datenobjekts empfangen wurden, wird der Status auf CP_OK gesetzt und ein erneuter expliziter Aufruf der Funktion <a class="el" href="group___c_p___user___interface.html#ga90c80a3049c202d757fdf0dba892634b" title="Starte Sendevorgang der initialisierten ID. ">CP_StartTx()</a> muss zum erneuten Empfang fuer diese ID erfolgen.</p>
<p class="startli">Sofern noch nicht alle Daten des Datenobjekts empfangen wurden, bleibt der Status auf CP_BUSY und der Empfangs-Prozess wird bei dem erneuten Aufruf dieser Funktion fortgesetzt.</p>
<p class="startli">Am Ende muss durch den Aufruf der Interrupt-Empfangs-Funktion: HAL_CAN_Receive_IT() der Interrupt-getriebene Empfang wieder aktiviert werden. Die Interrupts wurden von der HAL-Ebene vor dem Aufruf dieser Funktion ausgesetzt, sodass keine noch nicht verarbeiteten Daten ueberschrieben werden koennen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*CanHandle</td><td>CAN_Handle Object </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="gac3940c9c2948ca63ee5864f258f2ba94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3940c9c2948ca63ee5864f258f2ba94">&#9670;&nbsp;</a></span>HAL_CAN_TxCpltCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_CAN_TxCpltCallback </td>
          <td>(</td>
          <td class="paramtype">CAN_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>CanHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN-SENDE-PROZESS Interrupt Callback Transmit. </p>
<p>Interrupt Callback Functions.</p>
<p>Der CAN-Sendeprozess eines Datenobjekts wird durch den Anwender ueber die Anwenderfunktionen <a class="el" href="group___c_p___user___interface.html#ga90c80a3049c202d757fdf0dba892634b" title="Starte Sendevorgang der initialisierten ID. ">CP_StartTx()</a>in Gang gesetzt. Daraufhin erledigt diese Callback-Funktion den kompletten Sendeprozess indem diese mehrmals abgearbeitet wird. Zu Ihren Aufgaben gehoert das Datenmanagement der Segmentierung und das Versenden der einzelnen CAN-Nachrichten bis die Uebertragung des Datenobjekts abgeschlossen ist.</p>
<p>Um das Senden der einzelnen CAN-Nachrichten schnellst moeglich voranzutreiben, wird ein Interrupt des CAN-Controllers verwendet. Bei einem Sendevorgang wird die CAN-Nachricht zum Senden in eine Transmit-Mailbox abgelegt. Sobald die Nachricht versendet wurde, wird der Inhalt der Mailbox geloescht und Sie ist wieder leer. Dieses Ereignis Transmit Mailbox becomes empty loest einen Interrupt aus, der die Callback-Funktion Transmission Complete HAL_CAN_TxCpltCallback(..) aufruft. Bei jedem Aufruf dieser Funktion werden 6 Bytes des Datenobjekts ausgelesen, und in einer CAN-Nachricht versendet, worauf wieder ein Interrupt ausloest, der zum Senden des naechsten Datenpakets fuehrt. Dies wiederholt sich solange, bis alle Daten des Datenpakets gesendet wurden. Die Callback-Funktion ist in der HAL-Bibliothek in stm32f3xx_hal_can.c deklariert und zur eigenen Implementierung vorgesehen.</p>
<p>Waehrend der Abarbeitung der Callback-Funktion kann es durch einen erneut auftretenden Mailbox-Empty-Interrupt dazu kommen, dass die gleiche Funktion wieder aufgerufen wird. Das fuehrt dazu, dass die aktuelle Bearbeitung an unbestimmter Stelle innerhalb der Funktion durch den Interrupt unterbrochen / pausiert wird und diese Callback-Funktion, durch den zuletzt entstandenen Interrupt, erneut abgearbeitet wird. Dies wuerde zu undefinierbaren Fehlern fuehren. So koennte nach der Aenderung des Steuerungsfeldes Offset eine Unterbrechung stattfinden, ohne dass das Datenpaket ueberhaupt versendet wurde, nur um hier ein Beispiel zu nennen.</p>
<p>Aus genannten Gruenden wird der Sendeprozess zu Beginn der Funktion fuer eine parallele Nutzung blockiert durch das Setzen einer Variable CP_LockCANtx. Diese Lock-Variable wird nach der Abarbeitung der Funktion am Ende wieder freigegeben. Das Blockieren des Sendeprozess fuehrte jedoch zu folgendem Problem: Da zu dem Zeitpunkt des Interrupts die Callback-Funktion noch nicht fertig abgearbeitet war, ging somit der erneute Aufruf der Funktion durch die Blockierung verloren. Es gab nun keinen Prozess mehr, der die Callback-Funktion erneut aufruft. Somit war der CP-Sende-Vorgang unvollstaendig abgebrochen. Zur Loesung des Problems werden blockierte Aufrufe der Callback-Funktionen in einem Zaehler missed_IRs aufaddiert und nach der Abarbeitung, erneut aufgerufen. Somit laeuft kein Interrupt ins Leere. Jeder Interrupt wird benoetigt, da der Sendeprozess so oft aufgerufen werden muss, bis in diesem das Ende des Datenobjekts erreicht wird.</p>
<p>Zu Beginn wird nochmals geprueft, ob die ID im zugelassenen Wertebereich liegt und ob der das Steuerungsfeld Status auf CP_BUSY (Sendefreigabe) gesetzt ist.</p>
<p>Ist dies der Fall, wird die Nummerierung des zu versendenden Datenpaketes berechnet. Dieser Wert wird dann in die ersten 2 Datenbytes des CAN-Sendepuffers geschrieben. Als naechstes wird die benoetigte Laenge (DLC) der zu sendenden CAN-Botschaft berechnet. Dazu wird einfach die Laenge der noch insgesamt zu versendenden Bytes berechnet. Sollte die Laenge groesser oder gleich 8 Bytes sein, wird die Laenge auf die Maximal-Laenge eines normalen CAN-Frames gesetzt. Fuer das Kopieren der Daten aus dem Datenobjekt in den CAN-Sende-Puffer wird ein Adress-Zeiger auf das erste zu versendende Byte des Datenpakets gebildet. Dieser wird fuer das Kopieren des aktuellen Bytes in einer Schleife benoetigt. Mit jedem Schleifendurchlauf wird die Adresse des Zeigers um ein Byte erhoeht und das Datenbyte in den Sendepuffer kopiert. Dies geschieht solange, bis die berechnete Laenge des CAN-Frames (DLC) erreicht ist.</p>
<p>Zusaetzlich wird geprueft, ob der Offset, d.h. die bereits abgearbeiteten Bytes des Datenobjekts die Gesamtgroesse des Datenobjekts uebersteigt. Ist dies der Fall liegt ein Fehler vor und der Sendevorgang wird abgebrochen. Nach dem die Daten der Sendepuffer mit den Daten gefuellt ist, werden die Konfigurations-Parameter der CAN-Nachricht im CAN-Handle-Objekt gesetzt und das Senden des Datenpakets kann mit der CAN-Sende-Funktion gestartet werden.</p>
<p>Die Interrupt-getriebene CAN-Sende-Funktion bricht nach dem ersten fehlgeschlagenen Sendeversuch mit einem Fehler ab. Dies ist auch so gewollt. Jedoch ¬hat sich herausgestellt, dass der erste Sendeversuch ueber die Interrupt-getriebene Sendefunktion in selten Faellen nicht erfolgreich war. Die Gruende sind nicht bekannt. Es koennte zum Beispiel der Fall eingetreten sein, dass alle Transmit-Mailboxen belegt waren. Um den CP-Sendeprozess robuster gegen Ausfaelle zu machen, wurde daher eine Wiederholung von fehlgeschlagenen Sendeversuchen eingebaut. Abgebrochen werden die Sendeversuche dann erst wenn eine einstellbare Zeit ueberschritten wurde, die ueber den Parameter TIMEOUTCANTX, in der Datei <a class="el" href="cp__user_8h.html" title="CP Anwender-Interface. ">cp_user.h</a> in eingestellt werden kann. Zum Ende des Sendeprozesses wird geprueft, ob mit der zuletzt versendeten CAN-Nachricht alle Datenpakete des Datenobjekts versendet wurden. Ist dies der Fall wird der Offset zurueckgesetzt und das Steuerungsfeld Status auf den Zustand initialisiert gesetzt. Mit diesem Status wird die Callback-Funktion dann durch obige Pruefung trotz verbleibenden Interrupts oder Aufrufen durch verlorene Interrupts auch nicht mehr bearbeitet. Ein erneuter expliziter Aufruf durch die Funktion CP_StartTx muss zum erneuten Senden des Datenobjekts erfolgen. Sofern noch nicht alle Daten des Datenobjekts verschickt wurden, bleibt der Status auf CP_BUSY und der Interrupt-getriebene Sende-Prozess wird bei dem erneuten Aufruf dieser Funktion fortgesetzt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*CanHandle</td><td>CAN_Handle Object </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___c_p___control___layer_gac3940c9c2948ca63ee5864f258f2ba94_icgraph.png" border="0" usemap="#group___c_p___control___layer_gac3940c9c2948ca63ee5864f258f2ba94_icgraph" alt=""/></div>
<map name="group___c_p___control___layer_gac3940c9c2948ca63ee5864f258f2ba94_icgraph" id="group___c_p___control___layer_gac3940c9c2948ca63ee5864f258f2ba94_icgraph">
<area shape="rect" id="node2" href="group___c_p___user___interface.html#ga90c80a3049c202d757fdf0dba892634b" title="Starte Sendevorgang der initialisierten ID. " alt="" coords="228,29,317,56"/>
<area shape="rect" id="node3" href="group___c_p___example.html#gae907f73b0ed0c7eb71962eebfdd4c31a" title="Beispielprogamm zur Nutzung des CP&#45;Protokolls. " alt="" coords="365,29,461,56"/>
<area shape="rect" id="node4" href="main_8c.html#a840291bc02cba5474a4cb46a9b9566fe" title="main" alt="" coords="509,29,560,56"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga5889a924e4690d2d5f800001ee62776c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5889a924e4690d2d5f800001ee62776c">&#9670;&nbsp;</a></span>CP_LockCANtx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CP_LockCANtx = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable zum Sperren der Parallelen Bearbeitung des CallBack-SendeProzess. </p>

</div>
</div>
<a id="ga2641e3fde6fa5631f6ff5500078cef1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2641e3fde6fa5631f6ff5500078cef1f">&#9670;&nbsp;</a></span>missed_ir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t missed_ir = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable zum Zaehlen der blockierten Interrupts fuer eine spaetere wiederholte Ausfuehrung. </p>

</div>
</div>
<a id="gac997e9b383c699d06caa088a64dbac90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac997e9b383c699d06caa088a64dbac90">&#9670;&nbsp;</a></span>sFilterConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CAN_FilterConfTypeDef sFilterConfig</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable fuer die CAN-Filterkonfiguration. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jul 2 2017 15:53:33 for CP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
